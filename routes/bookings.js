const express = require('express');
const router = express.Router();
const Booking = require('../models/bookings');
const Slot = require('../models/Slots.js');
const { v4: uuidv4 } = require('uuid');
const authenticate = require('../middleware/authenticate'); 
const Payments = require('../models/Payments.js')

// Confirm booking by paying the fee
router.post('/:slotId/book-slot', authenticate, async (req, res) => {
    
    const customerId = req.user.customerId;
    const slotId = req.params.slotId;
    const { bookedFor } = req.body;

    const slot = await Slot.find( { slotId:slotId } );
    if(slot.status == "booked"){
        return res.status(400).send("Slot already booked")
    } 
    slot.status = "held";
    await slot.save();

    // code for booking payment (5rs)

    // if Payment become successful then this code snippet should return  paymentId
    const paymentId = uuidv4();   // This is just a dummy paymentId for now, in real scenario it should be generated by payment gateway

    try{

        const booking = new Booking({
            bookingId: uuidv4(),
            slotId: slotId,
            paymentId: paymentId,
            status: 'booked',
            bookedFor : bookedFor,
            bookedBy : customerId
        });
        slot.status = "booked";
        await slot.save();

        const payment = new Payments({
            paymentId: paymentId,
            slotId : slotId,
            paymentStatus: "pending_final_fee",
            bookingPaymentId: paymentId,
            bookingPaymentTime: new Date.now()
        })

        return res.status(200).send.json({ bookingId:booking.bookingId, paymentId:paymentId });

    } catch(err){
        return res.status(400).send( err );
    }
    
});

// Share OTP for slot start (Customer)
router.post('/:bookingId/start-otp', authenticate, async (req, res) => {
    const { bookingId } = req.params.bookingId;

    const booking = await Booking.findOne({ bookingId: bookingId, status: 'booked' });
    if(!booking){
        return res.status(400).send("Slot not booked")
    }

    const startOPT = Math.floor( Math.random() * 8999 ) + 10000;
    
  // booking = await Booking.findByIdAndUpdate(bookingId, { startOTP }, { new: true });

    booking.startOTP = startOPT;
    await booking.save();
    if (booking) {
        res.json({ message: 'Service Start OTP is ' + booking.startOTP });
    } else {
        res.status(400).json({ err: 'Booking not found' });
    }
});


// Verify OTP for slot start (Salon)
router.post('/:bookingId/verify-start-otp', authenticate, async (req, res) => {

        try{
            const bookingId = req.params.bookingId;
            const startOTP  = req.body;
            const booking = await Booking.findOne({ bookingId: bookingId });
        // if(!booking){
        //     return res.status(400).send("Start OTP not yet generated by customer")
        // }
    
  //  const booking = await Booking.findById(bookingId);

            if (booking && booking.startOTP === startOTP) {
                booking.status = 'in_progress';
                await booking.save();
                res.status(200);
            } else {
                res.status(400).json({ message: 'Invalid OTP' });
            }
        } catch (err){
            return res.status(400).send(err);
        }

});

// Mark service as ended
router.post('/end-service' ,authenticate, async (req, res) => {
    const { bookingId } = req.body;

    try{
        const booking = await Booking.findOne({ bookingId: bookingId, status: 'in_progress' });
        if(!booking){
            return res.status(400).send("Verify Start OTP before this")
        }
    
//    const booking = await Booking.findByIdAndUpdate(bookingId, { status: 'service-ended' }, { new: true });
    booking.status = 'service_ended';
    await booking.save();
        res.json({ message: 'Service marked as ended', booking });
    } catch(err){
        return res.status(400).send(err);
    }

});

// Share OTP for slot end (Customer)
router.post('/:bookingId/end-otp', authenticate, async (req, res) => {
    try{
        const bookingId = req.params.bookingId;
    const endOTP = Math.floor( Math.random() * 8999 ) + 10000;

    const booking = await Booking.findOne({ bookingId: bookingId, status: 'service_ended' });
    if(!booking){
        return res.status(400).send("Service not yet ended from Salon side.")
    }

   // const booking = await Booking.findByIdAndUpdate(bookingId, { endOTP }, { new: true });
    booking.endOTP = endOTP;
    await booking.save();
    res.json({ message: 'End OTP shared', booking });
    }
    catch(err){
        return res.status(400).send(err);
    }

    
});

// Verify OTP for slot end (Salon)
router.post('/:bookingId/verify-end-otp', authenticate, async (req, res) => {
    const { endOTP } = req.body;
    const bookingId = req.params.bookingId;

    const booking = await Booking.findOne({ bookingId: bookingId, status: 'service_ended' });
    if(!booking){
        return res.status(400).send("End OTP not yet generated by customer")
    }
    
 //   const booking = await Booking.findById(bookingId);

    if (booking && booking.endOTP === endOTP) {
        booking.status = 'completed';
        await booking.save();
        res.json({ message: 'End OTP verified and booking completed', booking });
    } else {
        res.status(400).json({ message: 'Invalid OTP' });
    }
});

// Complete the slot by making the final payment
router.post('/:bookingId/final-payment', authenticate, async (req, res) => {
    const bookingId = req.params.bookingId;

        const booking = await Booking.findOne({ bookingId: bookingId, status: 'completed' });
        if(!booking){
            return res.status(400).send("First verify end OTP")
        }

 //   const booking = await Booking.findByIdAndUpdate(bookingId, { paymentStatus, status: 'completed' }, { new: true });

 // code for payment gateway of final payment.
 
    const paymentId = uuidv4();   // This is just a dummy paymentId for now, in real scenario it should be generated by payment gateway 
    if(!paymentId){
        return res.status(400).send("Payment failed")
    }

    const slot = await Slot.findByIdAndUpdate(booking.slotId, { status: 'completed' }, { new: true });

    const payment = await Payments.findOneAndUpdate( 
       { bookingId: bookingId },
        { endPaymentId : paymentId,
          endPaymentTime : new Date.now(),
          paymentStatus : "done"
        } ,
        { new: true }
    )

    if (slot && payment) {
        res.status(200).json( "PaymentId is: " + paymentId );
    } else{
        res.status(400).json({ message: 'Payment failed' });
    }

});

// Salon sees slot status
// router.get(':salonId/status', authenticate, async (req, res) => {
//     const { salonId } = req.params;
    
//     const slot = await Slot.findOne({ salonId });
//     res.json(slot.status);
// });

module.exports = router;
